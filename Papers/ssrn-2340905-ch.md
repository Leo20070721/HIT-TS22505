理解 Dijkstra 算法
Muhammad Adeel Javaid
CompTIA 成员供应商咨询委员会

**摘要：**
Dijkstra 算法（以其发现者 E.W. Dijkstra 命名）解决了在图中从一个点（源点）到目标点寻找最短路径的问题。事实上，我们可以在相同时间内找到一个给定源点到图中所有点的最短路径，因此该问题有时也被称为单源最短路径问题。本文将借助简单易懂的示例和图示，帮助您理解 Dijkstra 算法的基础概念。

**引言：**
虽然像网络设计师和分析师这样的人需要对 Dijkstra 算法有透彻的理解，但对于我们其他人来说，进行一次简单而仔细的考察就足够了。我们不必以分步形式列出算法，而是直接来看一个示例求解过程。我们示例的目标是，在下图中找到从节点 A 到其他每个节点的最低成本路由。
[图 1]
首先，您需要创建一个表，如表 10-2(a)（下方所示），表中为除起始节点 A 之外的网络中的每个节点设置一列。该表还需要包含一个名为"已访问"的列，您将在此列出每个已被访问过的节点。更准确地说，当您在此列中列出一个节点时，表示您已经到达该节点并检查了该节点的所有直接邻居。此外，该表应包含一个名为"下一跳"的最后行，用于指示数据包离开节点 A 后应遍历的下一个节点（仅指下一个节点）。例如，如果节点 G 列下的"下一跳"值为 B，那么一个离开节点 A 且目的地为节点 G 的数据包，下一步应被传输到节点 B。在处理此示例时，您应记住，该算法的工作方式是，此表一旦完成（参见本节末尾的表 10-2(h)），仅显示从节点 A 到其他每个节点应进行的下一跳。就本示例而言，这意味着一旦您到达节点 B（在前往节点 G 的途中），您将需要查阅一个不同的表——即节点 B 的 Dijkstra 表——以确定下一跳。
[表 10-2(a) Dijkstra 算法初始表]

创建表格后，选择起始节点 A，访问它，并将起始节点添加到"已访问"列表中，如表 10-2(b) 所示。之后，定位节点 A 的每个直接邻居（仅一个链路或一跳之遥的节点）且该邻居尚未在"已访问"列表中。计算从节点 A 到这些邻居中每一个的旅行成本，并将这些值填入表中。例如，节点 B 距离节点 A 一跳，尚未被访问，从 A 到 B 的旅行成本为 2 个单位。在这种情况下，您应在表 10-2(b) 的节点 B 列中输入 2，以表示从节点 A 到节点 B 的路径成本，并在"下一跳"行中输入 B，注明要到达 B，您将在下一跳直接前往 B。您也可以从 A 到 C 一跳，成本为 4，"下一跳"值为 C；从 A 到 D 一跳，成本为 5，"下一跳"值为 D。这些值也记录在表 10-2(b) 中。请注意，我们尚未"访问"B、C 或 D。我们只访问了 A，并且我们仅仅检查了 A 与 B、A 与 C 以及 A 与 D 之间的链路成本。
[表 10-2(b) 访问节点 A 后的 Dijkstra 算法表]

没有更多节点是 A 的直接邻居，并且节点 A 的所有直接邻居链路都已被检查，因此您需要选择下一个要访问的节点。根据算法，下一个要访问的节点必须是当前表中成本最低的节点。因此，您必须选择节点 B。通过指定选择成本最低的下一个节点，该算法将在所有情况下找到最低成本。定位节点 B 的尚未被访问的直接邻居（目前只有 A 被访问），并确定从节点 A 经由节点 B 到节点 B 的每个直接邻居的旅行成本。请注意，节点 A 已被访问，因此您应在此阶段将其排除在考虑范围之外（没有必要走回头路）。节点 B 的尚未被访问的直接邻居是 D、E 和 G。从节点 A 经由节点 B 到节点 D 的成本是 4（从 A 到 B 的链路成本为 2，从 B 到 D 的链路成本为 2）。由于此成本小于直接从 A 到 D 的成本（如表 10-2(b) 所示，为 5），因此用新值 4 替换原值 5，以更新表格。此更新在表 10-2(c) 中高亮显示。您还应将节点 D 列下"下一跳"行中的 D 替换为 B，因为从节点 A 到节点 D 的新的最低成本路径现在始于数据包离开节点 A 后首先前往节点 B。
[表 10-2(c) 访问节点 A 和 B 后的 Dijkstra 算法表]

从 A 经由 B 到 E 的成本是 6 (2 + 4)，从 A 经由 B 到 G 的成本是 9 (2 + 7)。分别在 E 和 G 列中输入值 6 和 9，如表 10-2(d) 所示。B 也是 E 和 G 的"下一跳"值。
[表 10-2(d) 访问节点 A 和 B 后的 Dijkstra 算法表，续]

接下来让我们访问节点 C，因为正如您在表 10-2(d) 中看到的，它具有下一个最小的成本。C 的尚未被访问的直接邻居是 F 和 G。从 A 经由 C 到 F 的成本是 7 (4 + 3)。在 F 列中输入值 7，在"下一跳"行中输入值 C，如表 10-2(e) 所示。从节点 A 经由 C 到 G 的旅行成本是 9 (4 + 5)。由于这个新值 9 不小于表 10-2(d) 中的当前值（也是 9），因此在这种情况下无需更新表格。
[表 10-2(e) 访问节点 A、B 和 C 后的 Dijkstra 算法表]

接下来让我们访问节点 D，因为它具有下一个最小的成本。D 的尚未被访问的直接邻居是 E、F 和 G。从 A 经由 D（经由 B）到 E 的成本是 5 (4 + 1)。由于此值小于从 A 到 E 的当前成本（小于 6），通过在 E 列中输入 5 来更新表格（参见表 10-2(f) 作为参考）。我们仍然在离开 A 后首先前往 B 才能到达 E，因此"下一跳"行中的值 B 不会改变。从 A 经由 D 到 F 的成本是 10 (5 + 5)。从 A 经由 D 到 G 的成本也是 10。因为已输入 F 和 G 列中的值小于 10（换句话说，表格已经反映了这些节点的最低成本路径），所以您不需要更新表格。
[表 10-2(f) 访问节点 A、B、C 和 D 后的 Dijkstra 算法表]

下一个要访问的节点是 E。E 的尚未被访问的直接邻居是 G。从节点 A 经由节点 E（经由 D 经由 B）到节点 G 的旅行成本是 7 (2 + 2 + 1 + 2)。这条路径的成本 7 小于已填入 G 列中的值，因此您应该用这个新的、更小的值替换表中的当前值，如表 10-2(g) 所示。
[表 10-2(g) 访问节点 A、B、C、D 和 E 后的 Dijkstra 算法表]

下一个要访问的节点是 F。F 的尚未被访问的唯一直接邻居是 G。从节点 A 经由 F（经由 C）到节点 G 的旅行成本是 8。此成本不小于 F 的当前值，因此不更新表格。
最后一个要访问的节点是 G。但是，G 没有尚未被访问的直接邻居，因此我们完成了。
表 10-2(h) 显示了最终结果。从这个表中，您现在可以轻松查找从节点 A 到任何其他节点的最低成本路径。如果数据包源自节点 A 并且目的地是节点 x，路由器中的软件将简单地查阅表的 x 列以确定数据包下一步应前往何处。要找到从另一个节点开始的最低成本路由，您需要再次应用 Dijkstra 算法。例如，如果您希望找到从节点 C 到任何其他节点的最低成本路径，您将通过以节点 C 作为起始位置重复最低成本算法来生成一个新表。
[表 10-2(h) 从节点 A 开始的七节点子网应用 Dijkstra 算法的结果]

Dijkstra 算法为每个节点 j 分配一对标签 (pj, dj)，其中 pj 是在从节点 1 到 j 的现有最短路径上位于节点 j 之前的节点，dj 是该最短路径的长度。一些标签被称为临时的，即它们在后续步骤中可能会改变；一些标签被称为永久的，即它们是固定的，并且从节点 1 到被永久标记的节点的最短路径已被找到。
我们用 djk 表示弧 (j,k) 的长度。
步骤 1. 用永久标签 (Ø,0) 标记节点 1。用临时标签 (1, d1j) 标记每个满足 (1,j) 是图中一条弧的节点 j。用临时标签 (Ø,∞) 标记图中所有其他节点。
步骤 2. 令 j 是一个具有最小标签 dj 的临时标记节点，即
dj=min{dl: 节点 l 是临时标记的}。
对于每个满足 (j,k) 在图中存在的节点 k，如果 dk > dj + djk，则按如下方式重新标记 k：
pk=j, dk=dj+djk。
将节点 j 的标签视为永久的。
步骤 3. 重复步骤 2，直到图中所有节点都被永久标记。
通过读取标签 pj 可以找到最短路径。
示例。 找到从节点 1 到所有其他节点的最短路径。
我们将具有永久标签的节点标为红色。
从节点 1 到所有其他节点的最短路径：

**Dijkstra 算法示例**
已知：一个网络拓扑图 G，包含 6 个节点，节点间的链路成本如下所示：
求解：使用 Dijkstra 算法寻找从节点 A 到 F 的最低成本路径
解答：
令 T = {A, B, C, D, E, F} = 网络中的节点数
s = 源节点 = A
N = 迄今为止已处理的节点集合
c(i,j) = 如果两个节点直接连接，则为从节点 i 到节点 j 的链路成本。
= ∞ 如果 i 和 j 之间没有链路
D(v) = 当前已知的从节点 s 到节点 v 的最短路径（最低成本路径）的成本。当算法终止时，D(v) 是网络中从源点 s 到目的地 v 的最短路径的成本。
P(v): 从源点 s 到 v 的路径上的前驱节点，即紧接在 v 之前的节点

1) [初始化]
N = {A} 初始化集合 N 包含源节点 A
计算 v 属于集合 T 但不属于集合 N 的 D(v)。
需要计算 v = B, C, D, E, F 的 D(v)
2) [获取下一个节点]
找到不在 N 中且 D(w) 最小的 w。即上一步中最小的 D(w)，将该节点 w 添加到集合 N 中。如果相等，则随机选取其中一个。
本例中，D(D) = 1 是最小的，因此我们将节点 w = D 添加到集合 N。
N = { A, D }
3) [更新最短路径成本]
D(v) = min [ D(v), D(w) + c(w,v) ] 对于所有不在 N 中的节点 v
= min [ D(v), D(D) + c(D,v) ] 对于节点 v = B, C, E, F
4) [获取下一个节点]
找到不在 N 中且 D(w) 最小的 w。即上一步中最小的 D(w)，将该节点 w 添加到集合 N 中。如果相等，则随机选取其中一个。
本例中，D(E) 和 D(B) 具有相同的最小成本 2，我们随机选取一个。我们选择节点 w = E 加入集合 N。
N = { A, D, E }
5) [更新最短路径成本]
D(v) = min [ D(v), D(w) + c(w,v) ] 对于所有不在 N 中的节点 v
= min [ D(v), D(E) + c(E,v) ] 对于节点 v = B, C, F
6) [获取下一个节点]
找到上一步中最小的 D(v)，将该节点添加到 N。如果相等，随机选取其中一个。
D(B) 的成本最低 = 2。我们选择节点 w = B 加入集合 N。
N = { A, D, E, B }
7) [更新最短路径成本]
D(v) = min [ D(v), D(w) + c(w,v) ] 对于所有不在 N 中的节点 v
= min [ D(v), D(B) + c(B,v) ] 对于节点 v = C, F
8) [获取下一个节点]
找到上一步中最小的 D(v)，将该节点添加到 N。如果相等，选取其中任意一个。
D(C) 是最小的，因此我们将节点 w = C 添加到集合 N。
N = { A, D, E, B, C}
9) [更新最短路径成本]
D(v) = min [ D(v), D(w) + c(w,v) ] 对于所有不在 N 中的节点 n
= min [ D(v), D(C) + c(C,v) ] 对于节点 n = F
10) [获取下一个节点]
找到上一步中最小的 D(v)，将该节点添加到 N。如果相等，选取其中任意一个。
D(F) 是唯一剩下的节点，因此我们将节点 w = F 添加到集合 N。
N = { A, D, E, B, C, F }
N = T，因此算法终止。
11) 现在，我们需要写出从节点 A 到所有其他节点的最短路径。从后往前写，因为这些是到达各节点的最短路径成本，然后反向追溯到源节点 A。D(v) 列是从源节点 A 到 v 的最短路径成本。